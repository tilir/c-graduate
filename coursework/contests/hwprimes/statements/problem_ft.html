<head><h3>Problem FT -- тест Ферма</h3></head>
<body>
<p>Малая теорема Ферма</p>
<pre>
prime p, gcd(a, p) == 1 = > a ^ (p - 1) = 1 (mod p) 
</pre>
<p>Может быть использована для быстрой проверки простоты числа p: если удаётся найти <b>свидетеля</b>, то есть такое число a, что a<sup>(p - 1)</sup> != 1 (mod p), это автоматически значит, что число составное</p>
<p>Увы, в качестве свидетеля подходит не каждое число. Например для числа 221, число 38 удовлетворяет условиям теоремы Ферма, тем не менее число 221 составное. Такие числа, как 38 называются <b>лжецами</b> для числа 221</p>
<p>Ваша задача реализовать тест Ферма для чисел, меньших, чем 2<sup>64</sup> - 1 (unsigned long long)</p>
<p>Посылка должна состоять из программы, считывающей со стандартного ввода число P и выводящей на стандартный вывод 1, если оно простое и 0, если нет</p>
<p>Свидетеля можно искать перебором или пробовать случайные числа. Здесь есть элемент творческой неопределённости. Некоторые числа (т.н. числа Кармайкла), являясь составными, вообще не имеют свидетелей, но шансы натолкнуться на них довольно малы и ответ 1 для этих чисел в этой задаче будет правильным</p>
<p>Все входные числа &gt; 10<sup>8</sup>, так что вы можете даже не пробовать решето или проверку в лоб. Все входные числа &lt; 2<sup>64</sup> и все они положительны, поэтому использовать тип unsigned long long будет хорошей идеей</p>
<p>В примерах указана факторизация, но написать тест Ферма куда проще, чем факторизацию</p>
<br/>
<p>Пример 1</p>
<p>Вход: 100000001 (это 17 * 5882353)</p>
<p>Выход: 0</p>
<br/>
<p>Пример 2</p>
<p>Вход: 100000007</p>
<p>Выход: 1</p>
<br/>
<p>Пример 3</p>
<p>Вход: 413958827669 (это 70373 * 5882353)</p>
<p>Выход: 0</p>
<br/>
<p>Пример 4</p>
<p>Вход: 413958827741</p>
<p>Выход: 1</p>
<br/>
<p>Пример 5 (одно из чисел Кармайкла 7 * 13 * 17 * 23 * 31 * 67 * 73, тест Ферма не способен определить, что оно составное)</p>
<p>Вход: 5394826801</p>
<p>Выход: 1</p>
<br/>
</body>
