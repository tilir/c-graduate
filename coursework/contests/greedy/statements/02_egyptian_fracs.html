<head><h3>Problem EG &mdash; египетские дроби</h3></head> 
<body>
<p>Египетской дробью называется дробь, имеющая в числителе 1</p>
<p>Каждое число может быть разложено на египетские дроби жадным алгоритмом, который выбирает наибольшую дробь на каждом шаге</p>
<p>Например: 39/50 = 1/2 + 1/4 + 1/34 + 1/1700</p>
<p>Предоположим, что тип для массива знаменателей уже объявлен</p>
<pre>
struct denom_array_t { unsigned *arr; unsigned sz; };
</pre>
<p>Ваше задание написать функцию, которая берёт числитель и знаменатель и возвращает выделенный в динамической памяти массив знаменателей и его размер</p>
<p>Сигнатура этой функции должна быть следующей</p>
<pre>
struct denom_array_t egyptian_fractions(unsigned num, unsigned den)
</pre>
<p>Вы можете предполагать, что num &lt; den</p>
<p>Не забудьте, что дроби надо сокращать в процессе вычисления, чтобы их знаменатели не вылезали за диапазон значений беззнаковых целых</p>
<p>Возможно вам понадобится несколько раз реаллоцировать память в процессе вычисления массива и вы (чтобы избежать частых реаллокаций) будете делать это с запасом. Проследите чтобы перед выходом из функции поле sz было установлено в правильный размер, точно совпадающий с количеством знаменателей</p>
<p>В выходном массиве меньший знаменатель должен идти по младшему адресу</p>
<br/>
<p>Пример 1 (разобран выше)</p>
<p>Вход: n = 39, m = 50</p>
<p>Выход: {2, 4, 34, 1700}</p>
<br/>
<p>Пример 2 (тривиальный случай)</p>
<p>Вход: n = 1, m = 50</p>
<p>Выход: {50}</p>
<br/>
<p>Пример 3 (2/5 = 1/3 + 1/15)</p>
<p>Вход: n = 2, m = 5</p>
<p>Выход: {3, 15}</p>
<br/>
<p>Пример 4 (знаменатели могут быстро расти)</p>
<p>Вход: n = 1023, m = 1024</p>
<p>Выход: {2, 3, 7, 44, 9462, 373029888}</p>
<br/>
</body>
