<head>
<h3>Problem RU &mdash; ларьки под общую крышу</h3>
</head>
<body>
<p>На прямой расположены отрезки [xi, yi] которые все вместе полностью или даже с избытком покрывают интервал [L, R]</p>
<p>Тип для отрезка заранее задан и включает его номер, начало и конец</p>
<pre>
struct intvl_t { int number; int start; int fin; };
</pre>
<p>При этом некоторые отрезки могут начинаться и заканчиваться раньше, чем вообще начинается интересующий интервал, или гораздо позже. Вы можете быть уверены только в том, что те, которые точно покрывают этот интервал, среди них тоже есть</p>
<p>Вам нужно разработать функцию, с заранее заданной сигнатурой, которая выбирает наименьшее количество отрезков таким образом, чтобы они всё ещё покрывали интервал</p>
<pre>
int covermin(int L, int R, struct intvl_t *intervs, int nintervs);
</pre>
<p>Обратите внимание, что отрезки (0, 2) и (2, 4) вместе покрывают интервал (0, 4) то есть все концы включены</p>
<p>Обратите внимание также, что отрезки (0, 2) и (3, 4) вместе тоже покрывают интервал (0, 4) то есть задача -- покрыть все целые точки интерв    ала</p>
<p>Вы должны быть готовы к тому, что пришедший на вход массив интервалов никак не отсортирован</p>
<br/>
<p>Пример</p>
<img src="/tasks/cover_interval.png" alt="covering example"> 
<p>Красным помечено выбранное оптимальное множество. Для такого множества вы должны вернуть число 2</p>
<br/>
</body>
