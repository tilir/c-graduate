<head>
<h3>Problem JA &mdash; распределение работы</h3>
<style type="text/css">
   TABLE {
    width: 300px;
    border-collapse: collapse;
   }
   TD, TH {
    padding: 3px;
    border: 1px solid black;
   }
   TH {
    background: #b0e0e6;
   }
</style>
</head>
<body>
<p>У вас есть totaltime дней и n заказов, каждый из которых займёт один день. У каждого заказа есть номер, стоимость и дедлайн. Каждый заказ можно начинать в любой день до делайна, одновременно можно делать только один</p>
<p>Можете считать уже объявленными типы для описания одного заказа и для массива номеров заказов</p>
<pre>
// описание заказа
struct order_t { int number; int cost; int deadline; };

// массив номеров выбранных заказов и его размер
struct answer_t { int norders; int *numbers; };
</pre>
<p>Вы должны разработать функцию, которая выбирает наилучшее по максимальной стоимости выполнимое подмножество заказов</p>
<pre>
struct answer_t betforjobs(struct order_t * orders, int n, int totaltime);
</pre>
<p>Вы не должны полагаться на то, что входной массив как-то отсортирован</p>
<p>Может оказаться так, что существует несколько оптимальных решений. Просто верните любое из них</p>
<p>Обратите внимание: результирующий массив numbers должен быть выделен в динамической памяти</p>
<p><br/>Пример</p>
<table border="1">
   <tr>
    <th>number</th>
    <th>deadline</th>
    <th>cost</th>
   </tr>
   <tr><td>1</td><td>2</td><td>100</td></tr>
   <tr><td>2</td><td>1</td><td>27</td></tr>
   <tr><td>3</td><td>2</td><td>25</td></tr>
   <tr><td>4</td><td>1</td><td>19</td></tr>
   <tr><td>5</td><td>3</td><td>25</td></tr>
</table>
<p>В этом примере вы должны вернуть {3, 1, 5}</p>
<p>Совершенно не важно в каком порядке будут идти эти номера в результирующем массиве</p>
</body>
