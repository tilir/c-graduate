<head><h3>Problem FP &mdash; организация утренника</h3></head>
<body>
<p>Вам нужно организовать детский утренник на которых пришло nkids детей. У каждого ребёнка есть номер id и возраст age</p>
<p>Считайте, что все необходимые типы уже определены следующим образом</p>
<pre>
// ребёнок
struct kid_t { int id; int age; };

// соответствие номера ребёнка номеру группы
struct kidgroup_t { int nkid; int ngroup; };

// ответ это массив соответствия
// размер mapping = размеру массива детей
struct answer_t { int ngroups; struct kidgroup_t *mapping; };
</pre>
<p>Вы хотели бы получить минимальное количество групп, но при этом возраст детей в каждой группе не должен отличаться больше, чем на 2 года</p>
<p>Вам предлагается разработать функцию, которая формирует необходимые группы</p>
<pre>
struct answer_t funparty(struct kid_t *kids, int nkids);
</pre>
<p>Результирующий массив должен быть выделен в динамической памяти</p>
<p>Вы не должны полагаться на то, что входной массив с детьми как-то отсортирован</p>
<br/>
<p>Пример 1</p>
<p>Вход: {3, 4, 4, 6, 8}</p>
<p>Выход: {3, 4, 4}, {6, 8}</p>
<p>Здесь решение довольно очевидно: маленьких детей определяем в одну группу, более старших в другую</p>
<br/>
<p>Пример 2</p>
<p>Вход: {4, 5, 5, 6, 6, 8, 8, 9, 10, 11}</p>
<p>Выход: {4, 5, 5, 6, 6}, {8, 8, 9, 10}, {11}</p>
<p>Здесь та же логика, но в итоге получается три группы. Обратите внимание, нет ничего страшного если ребёнок в группе один</p>
<p>Альтернативный выход: {4, 5, 5}, {6, 6, 8, 8}, {9, 10, 11}</p>
<p>Тех же детей можно распределить и таким образом</p>
<p>Любой из этих ответов будет зачтён, потому что в обоих случаях число групп минимально и требования на возраст соблюдены</p>
<br/>
</body>
